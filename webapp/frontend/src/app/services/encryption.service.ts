import { Injectable } from '@angular/core';
import * as CryptoJS from 'crypto-js';
import * as forge from 'node-forge';
@Injectable({
  providedIn: 'root'
})
export class EncryptionService {
  // notes : the expected entropy bits is 64 because the base seed is an ethereum private key
  // and all the other entropy is generated from it
  // the seed is generated by hashing the private key with sha512 and then appending the hash to the private key ( 5 times )
  // Since we need the rsa keys to be deterministic from the private key, we use the seed as a prng
  // it would be usefull to find a way to add more entropy, either by asking a password or doing some math magic
  static async generateRSAKeyPairFromPrivateKey( priv_key: string) {
    const start = new Date().getTime();

    if(priv_key.startsWith('0x')){ //remove 0x so we keep maximum entropy
      priv_key = priv_key.substring(2);
    }
    var md: any = forge.md.sha512.create().update(priv_key).digest().bytes();
    const iterations = 5
    var seed : any= priv_key + md
    var hash_total_time = 0;
    for(var i = 0; i <iterations +1 ; i++){
      const hash_start_time = new Date().getTime();
      seed += forge.md.sha512.create().update(seed).digest().bytes();
      hash_total_time += new Date().getTime() - hash_start_time;
    }
    console.log("hashing took approx " + hash_total_time / iterations + "ms per hash");
    //TODO : RISK ASSESMENT
    seed = forge.util.createBuffer(seed);
    (seed as any).getBytesSync =  seed.getBytes; // this is a hack to make the seed compatible with the prng

    const kp = await forge.pki.rsa.generateKeyPair({
        bits: 4096,
        e: 0x10001,
        prng: seed
      });
    const private_key = kp.privateKey;
    const public_key = kp.publicKey;
    const keypair = { private_key, public_key };
    let elapsed = new Date().getTime() - start;
    console.log("RSA keypair generated in " + elapsed + "ms");
    return keypair;
  }


  static key_to_storage(keypair: any){
    return JSON.stringify({private_key: forge.pki.privateKeyToPem(keypair.private_key), public_key: forge.pki.publicKeyToPem(keypair.public_key)});
  }
  static key_from_storage(key: any){
    key = JSON.parse(key);
    return {private_key: forge.pki.privateKeyFromPem(key.private_key), public_key: forge.pki.publicKeyFromPem(key.public_key)};
  }

  static public_key_pem(keypair: any){
    return forge.pki.publicKeyToPem(keypair.public_key);
  }
  static async encryptData(data: string, publicKey: CryptoKey) {
    const encoder = new TextEncoder();
    const encryptedData = await crypto.subtle.encrypt(
      {
        name: 'RSA-OAEP',
      },
      publicKey,
      encoder.encode(data)
    );

    return encryptedData;
  }
  static async decryptData(encryptedData: ArrayBuffer, privateKey: CryptoKey) {
    const decryptedData = await crypto.subtle.decrypt(
      {
        name: 'RSA-OAEP',
      },
      privateKey,
      encryptedData
    );

    const decoder = new TextDecoder();
    return decoder.decode(decryptedData);
  }
  public static async encryptDataSymmetric(data: string, key: string): Promise<string> {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);

    const keyData = new TextEncoder().encode(key);
    const cryptoKey = await crypto.subtle.importKey(
      'raw', // Import the key in binary format
      keyData,
      'AES-CBC',
      false, // The imported key can't be extracted
      ['encrypt']
    );

    const iv = crypto.getRandomValues(new Uint8Array(16)); // Initialization vector
    const encryptedData = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, cryptoKey, encodedData);

    const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encryptedData))); // Convert ArrayBuffer to Base64

    return encryptedBase64;
  }

  public static async decryptDataSymmetric(encryptedData: string, key: string): Promise<string> {
    const keyData = new TextEncoder().encode(key);
    const cryptoKey = await crypto.subtle.importKey(
      'raw', // Import the key in binary format
      keyData,
      'AES-CBC',
      false, // The imported key can't be extracted
      ['decrypt']
    );

    const iv = new Uint8Array(16); // Use the same initialization vector used during encryption
    const encryptedArrayBuffer = new Uint8Array(atob(encryptedData).split('').map(char => char.charCodeAt(0))); // Convert Base64 to ArrayBuffer
    const decryptedData = await crypto.subtle.decrypt({ name: 'AES-CBC', iv }, cryptoKey, encryptedArrayBuffer);

    const decoder = new TextDecoder();
    const decryptedText = decoder.decode(decryptedData);

    return decryptedText;
  }
}
